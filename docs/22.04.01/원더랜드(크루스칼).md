# 2022.04.01 (ê¸ˆìš”ì¼)
### **1. ì›ë”ëœë“œ(ìµœì†ŒìŠ¤íŒ¨ë‹íŠ¸ë¦¬ : í¬ë£¨ìŠ¤ì¹¼, Union & Find í™œìš©)**

Q. ì›ë”ëœë“œì— ë¬¸ì œê°€ ìƒê²¼ë‹¤. ì›ë”ëœë“œì˜ ê° ë„ë¡œë¥¼ ìœ ì§€ë³´ìˆ˜í•˜ëŠ” ì¬ì •ì´ ë°”ë‹¥ë‚œ ê²ƒì´ë‹¤.    
   ì›ë”ëœë“œëŠ” ëª¨ë“  ë„ì‹œë¥¼ ì„œë¡œ ì—°ê²°í•˜ë©´ì„œ ìµœì†Œì˜ ìœ ì§€ë¹„ìš©ì´ ë“¤ë„ë¡ ë„ë¡œë¥¼ ì„ íƒí•˜ê³  ë‚˜ë¨¸ì§€ ë„ë¡œëŠ” íì‡„í•˜ë ¤ê³  í•œë‹¤.   
   ì•„ë˜ì˜ ê·¸ë¦¼ì€ ê·¸ í•œ ì˜ˆë¥¼ ì„¤ëª…í•˜ëŠ” ê·¸ë¦¼ì´ë‹¤.   
   ![](https://user-images.githubusercontent.com/94853413/161235906-829b680f-87f7-4fad-8056-21b8d4cdcf50.png)    
   ìœ„ì˜ ì§€ë„ëŠ” ê° ë„ì‹œê°€ 1ë¶€í„° 9ë¡œ í‘œí˜„ë˜ì—ˆê³ , ì§€ë„ì˜ ì˜¤ë¥¸ìª½ì€ ìµœì†Œë¹„ìš© 196ìœ¼ë¡œ ëª¨ë“  ë„ì‹œë¥¼ ì—°ê²°í•˜ëŠ” ë°©ë²•ì„ ì°¾ì•„ë‚¸ ê²ƒì´ë‹¤.    

**<í’€ì´ ë‚´ìš©>**
```java
import java.util.*;
// ì—°ê²°ëœ ì •ì ê³¼ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í´ë˜ìŠ¤ 
class Edge implements Comparable<Edge> {
    public int v1;
    public int v2;
    public int cost;

    Edge(int v1, int v2, int cost) {
        this.v1 = v1;
        this.v2 = v2;
        this.cost = cost;
    }
    // ê°€ì¤‘ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    @Override
    public int compareTo(Edge ob){
        return this.cost - ob.cost;
    }
}

class Main {
    static int[] unf;

    public static int Find(int v) {
        if (v == unf[v]) {
            return v;
        }
        else {
            return unf[v] = Find(unf[v]);
        }
    }

    public static void Union(int a, int b) {
        int fa = Find(a);
        int fb = Find(b);
        if (fa != fb) {
            unf[fa] = fb;
        }
    }

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        unf = new int[n+1];
        
        ArrayList<Edge> arr = new ArrayList<>();
        
        for (int i = 1; i <= n; i++) {
            unf[i] = i;
        }
        for (int i = 0; i < m; i++) { 
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            arr.add(new Edge(a, b, c));
        }
        int answer = 0;
        
        Collections.sort(arr);
        
        for (Edge ob : arr) {
            int fv1 = Find(ob.v1);
            int fv2 = Find(ob.v2);
            if (fv1 != fv2){
                answer += ob.cost;
                Union(ob.v1, ob.v2);
            }
        }
        System.out.println(answer);
    }
}
```


##  **ğŸ”¥ ìƒˆë¡œ ë°°ìš´ ë‚´ìš© ì •ë¦¬ & ëŠë‚€ ì **

      1. Kruskal's algorithm(í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜) ì´ë€?
      - ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ 
      - ëª¨ë“  ì •ì ì„ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ìµœì ì˜ í•´ë‹µì„ êµ¬í•˜ëŠ” ê²ƒ

      2. ë™ì‘ ê³¼ì •
      - ê·¸ë˜í”„ì˜ ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ì˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œë‹¤.
      - ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒí•œë‹¤.
      - ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ê°„ì„ ì€ ì œì™¸í•˜ê³ , ì‚¬ì´í´ì„ í˜•ì„±í•˜ì§€ ì•ŠëŠ” ê²½ìš°ëŠ” í•´ë‹¹ ê°„ì„ ì„ 
        ì§‘í•©ì— ì¶”ê°€í•œë‹¤.

      3. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ MST(Minimum Spanning Tree)ë€?
      - ìµœì†Œí•œì˜ ê°€ì¤‘ì¹˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆì„ ìˆ˜ ìˆê²Œ í•˜ëŠ” ê¸°ë²•

      4. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ì„ ìœ„í•œ ê¸°ë²•(union-find)
      - find : ì„œí´ì„ ì´ë£¨ëŠ”ì§€ í™•ì¸í•œë‹¤.
      - union : ì„œí´ì„ ì´ë£¨ì§€ ì•ŠëŠ”ë‹¤ë©´ ì—°ê²°í•œë‹¤.